#include "CPP_Boat.h"
#include "CPP_GameModeBase.h"
#include "Components/InputComponent.h"
#include "Components/StaticMeshComponent.h" 
#include "Kismet/GameplayStatics.h"
#include "CoreMinimal.h"
#include "Engine/Engine.h"
#include "Math/UnrealMathUtility.h"
#include "UObject/ConstructorHelpers.h"

// Sets default values
ACPP_Boat::ACPP_Boat()
{
    PrimaryActorTick.bCanEverTick = true;

    // 创建静态网格组件
    BoatMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("BoatMesh"));
    RootComponent = BoatMesh;

    // 创建SailSetting组件
    SailSetting = CreateDefaultSubobject<UCPP_SailSetting>(TEXT("SailSetting"));

    // 初始化船的属性
    PresentSpeed = 0.0f;
    BoatWindAngle = 0.0f;
    NavigationAngle = 0.0f;
    DeltaNavigationAngle = 0.0f;
    YawAngularSpeed = 0.0f;
}

void ACPP_Boat::BeginPlay()
{
    Super::BeginPlay();

    // Enable physics and gravity for the boat mesh
    if (BoatMesh)
    {
        BoatMesh->SetSimulatePhysics(true);
        BoatMesh->SetEnableGravity(true);
    }

    // Get a reference to the game mode
    GameMode = Cast<ACPP_GameModeBase>(UGameplayStatics::GetGameMode(GetWorld()));
}

void ACPP_Boat::Tick(float DeltaTime)
{
    Super::Tick(DeltaTime);

    // Update the delta navigation angle based on the boat's current yaw rotation
    DeltaNavigationAngle = AngleStandardizating(FMath::DegreesToRadians(BoatMesh->GetComponentRotation().Yaw)) - NavigationAngle;
    NavigationAngle += DeltaNavigationAngle;

    // Apply forces generated by the sails and player actions
    ApplySailAndPlayerForce(DeltaTime);
    
    // Normalize the navigation angle and update the wind angle relative to the boat
    NavigationAngle = AngleStandardizating(NavigationAngle);
    BoatWindAngle = NavigationAngle;

    // Get the boat's current transform and adjust its pitch to stabilize it
    FTransform MeshTransform = BoatMesh->GetComponentTransform();
    FRotator MeshRotation = MeshTransform.GetRotation().Rotator();
    
    // Force the pitch to remain at 2.0 degrees
    MeshRotation.Pitch = 2.0f;
    
    // Apply the modified rotation back to the boat mesh
    FQuat NewQuat = FQuat(MeshRotation);
    MeshTransform.SetRotation(NewQuat);
    
    // Set the boat mesh's world transform using physics
    BoatMesh->SetWorldTransform(MeshTransform, false, nullptr, ETeleportType::TeleportPhysics);

}

float ACPP_Boat::AngleStandardizating(float Angle)
{
    // Standardize the angle to be within [0, 2 * PI]
    if (Angle < 0)
    {
        Angle += 2 * PI;
    }
    else if (Angle >= 2 * PI)
    {
        Angle -= 2 * PI;
    }
    return Angle;
}

void ACPP_Boat::AxisTurn(float Value)
{
    // Constants for yaw scaling and max angular speed
    const float YAW_SCALE = 0.05f;
    const float MAX_YAW_ANGULAR_SPEED = 0.7f;

    // Update the yaw angular speed based on input
    YawAngularSpeed += Value * YAW_SCALE;

    // Clamp the yaw angular speed to the max limits
    if (YawAngularSpeed > MAX_YAW_ANGULAR_SPEED)
    {
        YawAngularSpeed = MAX_YAW_ANGULAR_SPEED;
    }
    else if (YawAngularSpeed < -MAX_YAW_ANGULAR_SPEED)
    {
        YawAngularSpeed = -MAX_YAW_ANGULAR_SPEED;
    }

    // Set the yaw rotation speed directly using physics
    BoatMesh->SetPhysicsAngularVelocityInRadians(FVector(0, 0, YawAngularSpeed), false, NAME_None);
}

void ACPP_Boat::AxisAdjustMainSail(float Value)
{
    // Adjust the main sail angle based on navigation and input value
    if (NavigationAngle > PI/2 && NavigationAngle < 3*PI/2 && (FMath::Abs(SailSetting->GetBoatMainSailAngle()) > PI/2 && SailSetting->GetBoatMainSailAngle() * Value > 0))
    {
        SailSetting->SetBoatMainSailAngle(FMath::Abs(Value)/Value * PI/2);
        return;
    }
    if (NavigationAngle < 5*PI/6 && NavigationAngle - DeltaNavigationAngle > 5*PI/6)
    {
        SailSetting->SetBoatMainSailAngle(-FMath::Abs(SailSetting->GetBoatMainSailAngle() + Value/180*PI));
        return;
    }
    if (NavigationAngle > 7*PI/6 && NavigationAngle - DeltaNavigationAngle < 7*PI/6)
    {
        SailSetting->SetBoatMainSailAngle(FMath::Abs(SailSetting->GetBoatMainSailAngle() + Value/180*PI));
        return;
    }
    if (NavigationAngle <= PI/2)
    {
        // Port side of the boat
        if (-SailSetting->GetBoatMainSailAngle() > NavigationAngle && SailSetting->GetBoatMainSailAngle() * Value >= 0)
        {
            SailSetting->SetBoatMainSailAngle(-NavigationAngle);
            return;
        }
        if (SailSetting->GetBoatMainSailAngle() > 0 && SailSetting->GetBoatMainSailAngle() * Value > 0)
        {
            SailSetting->SetBoatMainSailAngle(0);
            return;
        }
    }
    else if (NavigationAngle >= 3*PI/2)
    {
        // Starboard side of the boat
        if (SailSetting->GetBoatMainSailAngle() > 2*PI - NavigationAngle && SailSetting->GetBoatMainSailAngle() * Value >= 0)
        {
            SailSetting->SetBoatMainSailAngle(2*PI - NavigationAngle);
            return;
        }
        if (SailSetting->GetBoatMainSailAngle() < 0 && SailSetting->GetBoatMainSailAngle() * Value > 0)
        {
            SailSetting->SetBoatMainSailAngle(0);
            return;
        }
    }
    if (Value != 0.0f)
    {
        // Adjust the sail angle normally
        SailSetting->SetBoatMainSailAngle(SailSetting->GetBoatMainSailAngle() + Value/180*PI);
    }
}

void ACPP_Boat::AxisAdjustJib(float Value)
{
    // Adjust the jib sail angle similarly to the main sail
    if (NavigationAngle > PI/2 && NavigationAngle < 3*PI/2 && (FMath::Abs(SailSetting->GetBoatJibAngle()) > PI/2 && SailSetting->GetBoatJibAngle() * Value > 0))
    {
        SailSetting->SetBoatJibAngle(FMath::Abs(Value)/Value * PI/2);
        return;
    }
    if (NavigationAngle < 5*PI/6 && NavigationAngle - DeltaNavigationAngle > 5*PI/6)
    {
        SailSetting->SetBoatJibAngle(-FMath::Abs(SailSetting->GetBoatJibAngle() + Value/180*PI));
        return;
    }
    else if (NavigationAngle > 7*PI/6 && NavigationAngle - DeltaNavigationAngle < 7*PI/6)
    {
        SailSetting->SetBoatJibAngle(FMath::Abs(SailSetting->GetBoatJibAngle() + Value/180*PI));
        return;
    }
    if (NavigationAngle <= PI/2)
    {
        // Port side of the boat
        if (-SailSetting->GetBoatJibAngle() > NavigationAngle && SailSetting->GetBoatJibAngle() * Value > 0)
        {
            SailSetting->SetBoatJibAngle(-NavigationAngle);
            return;
        }
        if (SailSetting->GetBoatJibAngle() > 0 && SailSetting->GetBoatJibAngle() * Value > 0)
        {
            SailSetting->SetBoatJibAngle(0);
            return;
        }
    }
    else if (NavigationAngle >= 3*PI/2)
    {
        // Starboard side of the boat
        if (SailSetting->GetBoatJibAngle() > 2*PI - NavigationAngle && SailSetting->GetBoatJibAngle() * Value > 0)
        {
            SailSetting->SetBoatJibAngle(2*PI - NavigationAngle);
            return;
        }
        if (SailSetting->GetBoatJibAngle() < 0 && SailSetting->GetBoatJibAngle() * Value > 0)
        {
            SailSetting->SetBoatJibAngle(0);
            return;
        }
    }
    if (Value != 0.0f)
    {
        // Adjust the sail angle normally
        SailSetting->SetBoatJibAngle(SailSetting->GetBoatJibAngle() + Value/180*PI);
    }
}

void ACPP_Boat::AxisAdjustSpinnaker(float Value)
{
    // Adjust the spinnaker sail similarly to the other sails
    if (NavigationAngle > PI/2 && NavigationAngle < 3*PI/2 && (FMath::Abs(SailSetting->GetBoatSpinnakerAngle()) > PI/2 && SailSetting->GetBoatSpinnakerAngle() * Value > 0))
    {
        SailSetting->SetBoatSpinnakerAngle(FMath::Abs(Value)/Value * PI/2);
        return;
    }
    if (NavigationAngle < PI && NavigationAngle - DeltaNavigationAngle > PI)
    {
        SailSetting->SetBoatSpinnakerAngle(-FMath::Abs(SailSetting->GetBoatSpinnakerAngle() + Value/180*PI));
        return;
    }
    else if (NavigationAngle > PI && NavigationAngle - DeltaNavigationAngle < PI)
    {
        SailSetting->SetBoatSpinnakerAngle(FMath::Abs(SailSetting->GetBoatSpinnakerAngle() + Value/180*PI));
        return;
    }
    if (NavigationAngle <= PI/2)
    {
        // Port side of the boat
        if (-SailSetting->GetBoatSpinnakerAngle() > NavigationAngle && SailSetting->GetBoatSpinnakerAngle() * Value > 0)
        {
            SailSetting->SetBoatSpinnakerAngle(-NavigationAngle);
            return;
        }
        if (SailSetting->GetBoatSpinnakerAngle() > 0 && SailSetting->GetBoatSpinnakerAngle() * Value > 0)
        {
            SailSetting->SetBoatSpinnakerAngle(0);
            return;
        }
    }
    else if (NavigationAngle >= 3*PI/2)
    {
        // Starboard side of the boat
        if (SailSetting->GetBoatSpinnakerAngle() > 2*PI - NavigationAngle && SailSetting->GetBoatSpinnakerAngle() * Value > 0)
        {
            SailSetting->SetBoatSpinnakerAngle(2*PI - NavigationAngle);
            return;
        }
        if (SailSetting->GetBoatSpinnakerAngle() < 0 && SailSetting->GetBoatSpinnakerAngle() * Value > 0)
        {
            SailSetting->SetBoatSpinnakerAngle(0);
            return;
        }
    }
    if (Value != 0.0f)
    {
        if (SailSetting->IsSpinnakerOpen())
        {
            SailSetting->SetBoatSpinnakerAngle(SailSetting->GetBoatSpinnakerAngle() + Value/180*PI);
        }
        else
        {
            if (GEngine)
            {
                GEngine->AddOnScreenDebugMessage(-1, 1.0f, FColor::Red, TEXT("AxisAdjustSpinnaker: Spinnaker is not open"));
            }
        }   
    }
}

void ACPP_Boat::AxisHikingOutTrimmer(float Value)
{
    const float MaxInclinationAngle = 20;
    
    if (Value != 0.0f)
    {
        // Limit the hiking out angle if it exceeds the maximum
        if (FMath::Abs(RollHikingTorque) >= MaxInclinationAngle && RollHikingTorque * Value > 0) return;

        // Adjust the hiking out torque for the trimmer
        RollHikingTorque += Value;
        if (GEngine)
        {
            GEngine->AddOnScreenDebugMessage(-1, 1.0f, FColor::Cyan, FString::Printf(TEXT("AxisHikingOut: Value = %f, RollHikingTorque = %f"), Value, RollHikingTorque));
        }
    }
}

void ACPP_Boat::AxisHikingOutHelmsman(float Value)
{
    const float MaxInclinationAngle = 100;
    
    if (Value != 0.0f)
    {
        // Limit the hiking out angle if it exceeds the maximum
        if (FMath::Abs(RollHikingTorque) >= MaxInclinationAngle && RollHikingTorque * Value > 0) return;

        // Adjust the hiking out torque for the helmsman
        RollHikingTorque += Value;
        if (GEngine)
        {
            GEngine->AddOnScreenDebugMessage(-1, 1.0f, FColor::Cyan, FString::Printf(TEXT("AxisHikingOut: Value = %f, RollHikingTorque = %f"), Value, RollHikingTorque));
        }
    }
}

void ACPP_Boat::ActionToggleSpinnaker()
{
    // Toggle the spinnaker state (open/close)
    SailSetting->SetSpinnakerOpen(!SailSetting->IsSpinnakerOpen());
    
    if (GEngine)
    {
        GEngine->AddOnScreenDebugMessage(-1, 1.0f, FColor::Magenta, FString::Printf(TEXT("ActionToggleSpinnaker: Spinnaker is now %s"), SailSetting->IsSpinnakerOpen() ? TEXT("open") : TEXT("closed")));
    }
}

void ACPP_Boat::ApplySailAndPlayerForce(float DeltaTime)
{
    // Constants for scaling roll and forward forces
    const float ROLL_SCALE = 0.5f;
    const float FORWARD_SCALE = 60000.0f;

    // Get the forward vector of the boat
    FVector ForwardVector = BoatMesh->GetForwardVector();
    
    // Get forces from the sail settings
    float RollSailTorque = SailSetting->GetRollSailTorque();
    float ForwardSailForce = SailSetting->GetForwardSailForce();

    // Calculate the total roll torque (sail torque minus hiking out torque)
    float TotalRollTorque = RollSailTorque - RollHikingTorque;
    
    // Apply roll torque to the boat
    BoatMesh->AddTorqueInRadians(ForwardVector * TotalRollTorque * ROLL_SCALE, NAME_None, true);

    // 使用质量计算出需要施加的力
    FVector ForceToAdd = ForwardVector * ForwardSailForce * FORWARD_SCALE; 

    BoatMesh->AddForce(ForceToAdd);
    // 获取当前世界坐标系中的速度
    FVector WorldVelocity = BoatMesh->GetPhysicsLinearVelocity();
        
    // 将世界速度转换为Pawn的本地坐标系
    FVector LocalVelocity = BoatMesh->GetComponentTransform().InverseTransformVector(WorldVelocity);

    // 将本地y轴速度设置为0
    LocalVelocity.Y = 0.0f;

    // 将调整后的速度转换回世界坐标系
    FVector AdjustedWorldVelocity = BoatMesh->GetComponentTransform().TransformVector(LocalVelocity);

    // 将修改后的世界速度应用到Pawn上
    BoatMesh->SetPhysicsLinearVelocity(AdjustedWorldVelocity);
}
 
FVector2D ACPP_Boat::GetPawnLocation() const
{
    // Get the actor's 3D location
    FVector PawnLocation3D = this->GetActorLocation();

    // Convert FVector to FVector2D by ignoring the Z axis
    FVector2D PawnLocation(PawnLocation3D.X, PawnLocation3D.Y);

    return PawnLocation;
}